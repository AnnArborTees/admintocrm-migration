class Job < ActiveRecord::Base
  belongs_to :order, foreign_key: :jobbable_id
  has_many :line_items, foreign_key: :line_itemable_id
  has_many :imprints, foreign_key: :job_id

  validates :order, presence: true
  validates :name, presence: true
  validates :description, presence: true

  def self.new_job_from_admin_job(admin_job)
    if admin_job.title.blank?
      return nil
    end

    self.find_or_initialize_by( 
      name: admin_job.title,
      description: admin_job.description,
    )
  end
  
  def determine_DTG_variant(key, imprint_methods)
    
    #if key isn't dtg, as in 381/782/541 send it here
    #then it changes key to dtg, as there is a dtg
    #associated with the original key that sent it here
    if key != 'dtg'
      key = 'dtg'
    end

    name = self.name.downcase
    
    num_782_found = name.scan('782').size
    num_381_found = name.scan('381').size
    num_541_found = name.scan('541').size

    #all possible matches of dtg
    #if 782, 381 or 541 has been found, it runs through this statement
    if num_782_found > 0 || num_381_found > 0 || num_541_found > 0  
      if num_782_found > 0
        if name.include? "782 front and back" || name.include?("782 f/b")
          imprint_methods << IMPRINT_MAP[key + "wfb"]
        else
          imprint_methods << IMPRINT_MAP[key + 'w']
        end
      end

      if num_381_found > 0
        if name.include?("381 f/b") || name.include?("381 fr/bk") || name.include?("381 fr/back")
          imprint_methods << IMPRINT_MAP[key + "wfb"]
        elsif name.include?("381nw")
          imprint_methods << IMPRINT_MAP[key]
        elsif name.include?("381 b")
          imprint_methods << IMPRINT_MAP[key + "wb"]
        else
          imprint_methods << IMPRINT_MAP[key + "w"] 
        end
      end
    
      if num_541_found > 0
        if name.include?("541 f/b") || name.include?("541 f+b") || name.include?("541 front and back")
          imprint_methods << IMPRINT_MAP[key + "nwfb"]
        else
          imprint_methods << IMPRINT_MAP[key]
        end
      end
    else
    end
  end
  
  def determine_color_difference(key, imprint_methods)
    num_keyB_found = self.name.downcase.scan(key+'b').size
    num_keyS_found = self.name.downcase.scan(key+'s').size
    num_key_found = self.name.downcase.scan(key).size

    if(num_key_found > 1)#finds either a #c and a #cf or a #cb or a #cs
      if(num_keyB_found >= 1 || num_keyS_found >= 1)#more concerned about the #cb/cs however
        imprint_methods << IMPRINT_MAP[key]
        if(num_keyB_found >=1)
          imprint_methods << IMPRINT_MAP[key + 'b']
        else
          imprint_methods << IMPRINT_MAP[key + 's']
        end
      else
        imprint_methods << IMPRINT_MAP[key]
      end
    else
      if(num_keyB_found == 0 && num_keyS_found == 0)
        imprint_methods << IMPRINT_MAP[key]
      else
        if(num_keyB_found != 0)
          imprint_methods << IMPRINT_MAP[key + 'b']
        else
          imprint_methods << IMPRINT_MAP[key + 's']
        end
      end
    end

    if name == "m-powered (2cf, 2cb)"
      byebug
    end1
  end

  def determine_imprint_methods
    imprint_methods = []
    IMPRINT_MAP.each do |key, val|
      if self.name.downcase.include?(key) || self.description.downcase.include?(key)         
        if key.last == 'c' #this is for determining between a 1c and a 1cb/1cs.
          self.determine_color_difference(key, imprint_methods)
        else
          imprint_methods << IMPRINT_MAP[key]
        end
        

        #if key == "dtg"
         # byebug
        #end
        #all of these are variants of DTG's
       # if key == "dtg" || key == "381" #|| key == "782" || key == "541" 
        #  self.determine_DTG_variant(key, imprint_methods)
        #else
         # imprint_methods << IMPRINT_MAP[key]
        #end
      end
    end
    return imprint_methods.uniq
  end
end
